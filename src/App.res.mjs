// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

function arrayRange(n) {
  return Core__Array.make(n, 0).map(function (param, i) {
              return i;
            });
}

function groupPairs(a) {
  return Core__Array.reduce(a, [
                [],
                undefined
              ], (function (param, cur) {
                  var col = param[1];
                  var arr = param[0];
                  if (col !== undefined) {
                    return [
                            Belt_Array.concatMany([
                                  arr,
                                  [[
                                      Caml_option.valFromOption(col),
                                      cur
                                    ]]
                                ]),
                            undefined
                          ];
                  } else {
                    return [
                            arr,
                            Caml_option.some(cur)
                          ];
                  }
                }))[0];
}

function isWin(p1, p2) {
  return Math.random() < p1 / (p1 + p2);
}

function getPlacement(d) {
  var _t = [0];
  var _depth = d - 1 | 0;
  while(true) {
    var depth = _depth;
    var t = _t;
    var level = t.length;
    var rank = Belt_Array.concatMany(t.map((function(level){
            return function (v) {
              return [
                      v,
                      ((level << 1) - v | 0) - 1 | 0
                    ];
            }
            }(level))));
    if (depth <= 0) {
      return rank;
    }
    _depth = depth - 1 | 0;
    _t = rank;
    continue ;
  };
}

function getPlayers(num) {
  return arrayRange(num).map(function (i) {
                  return Math.pow(1 + (i + 1 | 0) / num, 5);
                }).toSorted(function (a, b) {
                return b - a;
              }).map(function (v, i) {
              return {
                      id: i,
                      skill: v
                    };
            });
}

function runRound(round) {
  var match = Belt_Array.unzip(groupPairs(round).map(function (param) {
            var p2 = param[1];
            var p1 = param[0];
            if (isWin(p1.skill, p2.skill)) {
              return [
                      p1,
                      p2
                    ];
            } else {
              return [
                      p2,
                      p1
                    ];
            }
          }));
  return [
          match[0],
          match[1]
        ];
}

function runRounds(round1) {
  var recF = function (_winners, _losers) {
    while(true) {
      var losers = _losers;
      var winners = _winners;
      var match = runRound(winners);
      var newLosers = match[1];
      var newWinners = match[0];
      if (newWinners.length < 2) {
        return [
                newWinners,
                losers.concat(newLosers)
              ];
      }
      _losers = losers.concat(newLosers);
      _winners = newWinners;
      continue ;
    };
  };
  var match = recF(round1, []);
  var winner = match[0][0];
  return [
          winner,
          match[1]
        ];
}

function runRoundsWithLosers(round1) {
  var recF = function (_playing, _sittingOut, _comebackRound) {
    while(true) {
      var comebackRound = _comebackRound;
      var sittingOut = _sittingOut;
      var playing = _playing;
      var match = runRound(playing);
      var newLosers = match[1];
      var newWinners = match[0];
      if (newWinners.length < 2) {
        return [
                newWinners,
                sittingOut.concat(newLosers)
              ];
      }
      if (comebackRound) {
        _comebackRound = !comebackRound;
        _sittingOut = sittingOut.concat(newLosers);
        _playing = newWinners;
        continue ;
      }
      var shuffled = Core__Array.toShuffled(sittingOut);
      var luckyFew = shuffled.slice(0, newWinners.length);
      var stillOut = shuffled.slice(newWinners.length);
      _comebackRound = !comebackRound;
      _sittingOut = stillOut.concat(newLosers);
      _playing = newWinners.concat(luckyFew);
      continue ;
    };
  };
  var match = recF(round1, [], false);
  var winner = match[0][0];
  return [
          winner,
          match[1]
        ];
}

function runTournament() {
  var num = Math.pow(2, 4) | 0;
  var placement = getPlacement(4);
  var winsRegular = Core__Array.reduce(arrayRange(1000), Core__Array.make(num, 0), (function (acc, cur) {
          var players = getPlayers(num);
          var round1 = placement.map(function (p) {
                return players[p];
              });
          var match = runRounds(round1);
          var winner = match[0];
          return acc.map(function (v, i) {
                      if (winner.id === i) {
                        return v + 1 | 0;
                      } else {
                        return v;
                      }
                    });
        }));
  var winsLosers = Core__Array.reduce(arrayRange(1000), Core__Array.make(num, 0), (function (acc, cur) {
          var players = getPlayers(num);
          var round1 = placement.map(function (p) {
                return players[p];
              });
          var match = runRoundsWithLosers(round1);
          var winner = match[0];
          return acc.map(function (v, i) {
                      if (winner.id === i) {
                        return v + 1 | 0;
                      } else {
                        return v;
                      }
                    });
        }));
  console.log(winsRegular, winsLosers);
}

runTournament();

function App(props) {
  return JsxRuntime.jsx("div", {
              className: "p-6"
            });
}

var make = App;

export {
  make ,
}
/*  Not a pure module */
