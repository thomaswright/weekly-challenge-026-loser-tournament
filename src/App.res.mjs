// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

function groupPairs(a) {
  return Core__Array.reduce(a, [
                [],
                undefined
              ], (function (param, cur) {
                  var col = param[1];
                  var arr = param[0];
                  if (col !== undefined) {
                    return [
                            Belt_Array.concatMany([
                                  arr,
                                  [[
                                      Caml_option.valFromOption(col),
                                      cur
                                    ]]
                                ]),
                            undefined
                          ];
                  } else {
                    return [
                            arr,
                            Caml_option.some(cur)
                          ];
                  }
                }))[0];
}

function boundGaussian() {
  while(true) {
    var u = 1 - Math.random();
    var v = Math.random();
    var z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * 3.14159265 * v);
    var scaled = z / 10.0 + 0.5;
    if (!(scaled < 0 || scaled > 1)) {
      return scaled;
    }
    _param = undefined;
    continue ;
  };
}

function isWin(p1, p2) {
  return Math.random() > p1 / (p1 + p2);
}

function getPlacement(d) {
  var _t = [0];
  var _depth = d - 1 | 0;
  while(true) {
    var depth = _depth;
    var t = _t;
    var level = t.length;
    var rank = Belt_Array.concatMany(t.map((function(level){
            return function (v) {
              return [
                      v,
                      ((level << 1) - v | 0) - 1 | 0
                    ];
            }
            }(level))));
    if (depth <= 0) {
      return rank;
    }
    _depth = depth - 1 | 0;
    _t = rank;
    continue ;
  };
}

function getPlayers(num) {
  return Core__Array.make(num, 0).map(function (param) {
                  return boundGaussian();
                }).toSorted(function (a, b) {
                return b - a;
              }).map(function (v, i) {
              return {
                      id: i,
                      skill: v
                    };
            });
}

function runRound(round) {
  var match = Belt_Array.unzip(groupPairs(round).map(function (param) {
            var p2 = param[1];
            var p1 = param[0];
            if (isWin(p1.skill, p2.skill)) {
              return [
                      p1,
                      p2
                    ];
            } else {
              return [
                      p2,
                      p1
                    ];
            }
          }));
  return [
          match[0],
          match[1]
        ];
}

function runRounds(_winners, _losers) {
  while(true) {
    var losers = _losers;
    var winners = _winners;
    var match = runRound(winners);
    var newLosers = match[1];
    var newWinners = match[0];
    if (newWinners.length < 2) {
      return [
              newWinners,
              Belt_Array.concatMany([
                    losers,
                    [newLosers]
                  ])
            ];
    }
    _losers = Belt_Array.concatMany([
          losers,
          [newLosers]
        ]);
    _winners = newWinners;
    continue ;
  };
}

function runTournament() {
  var num = Math.pow(2, 4) | 0;
  var players = getPlayers(num);
  var placement = getPlacement(4);
  var round1 = placement.map(function (p) {
        return players[p];
      });
  var match = runRounds(round1, []);
  console.log(match[0], match[1]);
}

runTournament();

function App(props) {
  return JsxRuntime.jsx("div", {
              className: "p-6"
            });
}

var make = App;

export {
  make ,
}
/*  Not a pure module */
